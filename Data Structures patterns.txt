important Data Structures : 7-12 LPA
array 
strings
linked list
stack & queue
tree

Algorithms:
Sorting -> quick sort, merge sort, bubble sort, insertion sort, selection sort, heap sort {counting sort, radix sort, bucket sort}
searching -> binary search, linear search
dynamic programming -> recrusion + memoization, tabulation
greedy algorithms -> knapsack, job scheduling, huffman coding

Strings algorithms:
1. KMP
2. Rabin Karp
3. Z algorithm

practice patterns:

1. Array
a1 -> two pointer
a2 -> sliding window
a3 -> fast and slow pointer -> 2x speed pointer and 1x speed pointer {rabbit and turtle}
a4 -> merge intervals
a5 -> sub array 
a6 -> subsequences

2 String
s1 -> palindrome
s2 -> anagram -> nani -> inan
s3 -> sliding window
s4 -> two pointer
s5 -> reverse string    
s6 -> string matching
s7 -> string parsing
s8 -> string manipulation
s9 -> string compression
s10 -> string encoding

3. Linked List
l1 -> reverse linked list
l2 -> detect cycle
l3 -> merge linked list
l4 -> find middle of linked list
l5 -> remove nth node from end
l6 -> remove duplicates
l7 -> odd even linked list
l8 -> rotate linked list by k
l9 -> swap nodes in pairs

4. Stack and Queue
sq1 -> implement stack using array
sq2 -> implement stack using linked list
sq3 -> implement queue using array
sq4 -> implement queue using linked list
sq5 -> implement stack using queue
sq6 -> implement queue using stack
sq7 -> sliding window maximum
sq8 -> largest rectangle in histogram
sq9 -> evaluate reverse polish notation -> a+b -> ab+
sq10 -> valid parenthesis -> ()[]{} 
sq11 -> exclusive time of functions
sq12 -> design circular queue
sq13 -> design circular deque
sq14 -> design a stack that supports push, pop, top, and retrieving the minimum element in constant time

5. Tree
t1 -> binary tree traversal -> inorder, preorder, postorder
t2 -> level order traversal -> vertical order traversal, zigzag traversal
t3 -> binary search tree -> insert, delete, search, find min, find max, find kth smallest, find kth largest
t4 -> balanced binary tree -> check if tree is balanced, convert binary tree to balanced binary tree
t5 -> binary tree path -> find path from root to leaf, find path from root to node
t6 -> binary tree diameter -> find diameter of binary tree
t7 -> binary tree lowest common ancestor -> find lowest common ancestor of two nodes
t8 -> binary tree right side view -> find right side view of binary tree
t9 -> binary tree boundary traversal -> find boundary traversal of binary tree

6. Recursion and Backtracking
r1 -> permutation
r2 -> combination
r3 -> subset
r4 -> palindrome partitioning
r5 -> letter case permutation
r6 -> generate parenthesis
r7 -> n queens
r8 -> sudoku solver
r9 -> word search
r10 -> regular expression matching
r11 -> wildcard matching
r12 -> decode ways
r13 -> generate parentheses
r14 -> subsets
r15 -> permutations
r16 -> combination sum
r17 -> combination sum 2
r18 -> palindrome partitioning


7. Graph
g1 -> graph traversal -> bfs, dfs
g2 -> shortest path -> dijkstra, bellman ford, floyd warshall
g3 -> minimum spanning tree -> kruskal, prim
g4 -> topological sort
g5 -> detect cycle in directed graph
g6 -> detect cycle in undirected graph
g7 -> bipartite graph
g8 -> articulation points
g9 -> bridges
g10 -> eulerian path
g11 -> hamiltonian path
g12 -> travelling salesman problem
g13 -> flood fill
g14 -> number of islands
g15 -> alien dictionary
g16 -> course schedule
g17 -> network delay time
g18 -> clone graph
g19 -> word ladder
g20 -> word ladder 2
g21 -> word search
g22 -> word search 2\